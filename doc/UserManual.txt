  
User Manual For AEG Mesher
==========================

I. D. Flintoft
M. Berens


Overview
========

Structured mesh generator - uniform and non-uniform cuboid meshes.

MATALB/OCtave script - no built in GUI but Gmsh can be used to view
input mesh, mesh lines and output mesh.

Input is an unstructured mesh of the objects to be meshed. This can be 
generated using many different tools, e.g. Gmsh.

Input meshes in Gmsh, AMELET-HDF formats supported natively.
Many other formata can be input via Gmsh.

Meshing control parameters are set in the script.

Material database can be used to inform appropriate mesh density 
for electromagnetic simluations.

Generic structured mesh created internal. 

Currently can be exported to the UoY Vulture FDTD code mesh format.

Easy to add exporters for other codes.

Also provides some mesh conversion capability, e.g can export
unstructured meshes to CONCEPT-II format (not dielectrics).

Creating unstructured input meshes
==================================

The structure to be meshed must be described using
an unstructured mesh containing each material
object. The internal format of the unstructured mesh 
is described in Appendix A.

Each material object is represented as a named 
group of mesh elements. Elements of dimensions
0 (node), 1 (line), 2 (surface) and 3 (volume)
are supported by the format. However 3D elements
are not used for mesh generation - volumetric 
material objects should be described by their closed 
boundary surface. Currently only triangular surface 
elements are supported by the mesh mapping functions. 


Material type       Unstructured mesh representation
--------------------------------------------------------
volumetric VOLUME   closed bounding surface (tri3)
                    no check is made for closed surface
                      
surface material    surface (tri3)
                    can be closed or open
                      
wire material       lines (bar2)

points              nodes (node0)
--------------------------------------------------------

Each group must be a complete representation of the object.
In particular any elements belonging to shared intersection 
surfaces between objects must be included in the groups
for both objects. Meshing of objects in done individually - the
input mesh can contain duplicate elements, for shared surfaces
for example; however duplicate elements must be identical to
avoid meshing aretacts.


Reading and writing meshes
==========================

The primary on-disk mesh format is the Gmsh ASCII format version 2.

Functions are provided to read and write this format:

meshReadGmsh()
meshWriteGmsh()
meshMergeUnstructured()
             
Option handling
===============

meshSetDefaultOptions()

Mesh line generation options
----------------------------

Global options summary:
 
  options.mesh.
  
  --------------------------------------------------------------------------------------------------
  Name             Type               Default       Units Range
  --------------------------------------------------------------------------------------------------
  meshType         string             'CUBIC'       -     'CUBIC', 'UNIFORM', 'NONUNIFORM'
  lineAlgorithm    string             'OPTIM1'      -     'OPTIM1', 'OPTIM2'
  costAlgorithm    string             'RMS'         -     'RMS', 'MEAN', 'MAX'
  epsCoalesceLines real               1e-4          ?     >=0
  useMeshCompVol   boolean            true          -     true, false
  compVolName      string             'CompVolume'  -     
  compVolAABB      real 1x6 vector    []            m     >=-Inf, <=Inf 
  compVolIsTight   boolean 1x6 vector all false     -     true , false
  useDensity       boolean            true          -     true, false
  Dmin             real               10            -     >0
  Dmax             real               10            -     >0>=Dmin  
  dmin             real               []            m     >0
  dmax             real               []            m     >0
  epsCompVol       real               1e-6          ?     >=0
  maxRatio         real               1.5           -     >=1
  maxAspect        real               2.0           -     >=1
  minFreq          real               1e6           Hz    >=0
  maxFreq          real               3e9           Hz    >=0, >=minFreq
  numFreqSamp      integer            50            -     >=1
  maxOptimTime     real               5             s     >=0.0
  maxOptimEvals    integer            10000         -     >=0
  costFuncTol      real               1e-6          ?     >=0.0
  isPlot           boolean            false         -     true, false
  --------------------------------------------------------------------------------------------------

  meshType - determines whether to use uniform or non-uniform mesh lines.
  
  lineAlgorithm - chooses the algorithm used for optimsiation of the location of the
                  mesh lines.
                  
  costAlgorithm - chooses the cost function used in the optimisation of the mesh line
                  locations.
                  
  epsCoalesceLines - tolerance [FIXME] below which constraint points are merged before the mesh line
                     generation algorithm is run. Currently uses non-transistive algorithm so use with care!
                     
  useMeshCompVol - indicates the computational volume should be determined from the bounding
                   box of a group contained in the input mesh.
                   
  compVolName - name of the mesh group to use for determining the computational volume. Only
                effective when useMeshCompVol is true.
                
  compVolAABB - a row vector, [ x_lo y_lo z_lo x~_hi y_hi z_hi ], containing the bounding box
                coordinates to use for the computational volume. Used if useMeshCompVol is false.
                If empty and useMeshCompVol is false the minimal AABB of the objects to be mesh
                is used as computational volume.

  compVolIsTight - booleen vector indicating if lowest and highest mesh lines should be forced to be exactly
                   conincident with the computational volume.

  dmin - a real scalar specifying the minimum global mesh size of the computational volume. Used if useMeshCompVol is false.
 
  dmax - a real scalar specifying the maximum global mesh size of the computational volume. Used if useMeshCompVol is false.

  epsCompVol - tolerance [FIXME]
  
  maxRatio - maximum cell size ratio between neighbouring cells.
  
  maxAspect - maximum cell aspect ratio to allow in the mesh.
  
  minFreq - minimum frequency for the mesh. Used to determine mesh line densities and waveform
            parameters. 
            
  maxFreq - maximum frequency for the mesh. Used to determine mesh line densities and waveform
            parameters. 
            
  numFreqSamp - number of frequency samples to use for evaluation of complex permittivities of
                materials when maximum mesh sizes are being determined from material database
                and mesh densities.
 
  maxOptTime - maximum time for optimisations used to determine mesh line locations.
  
  maxOptimEvals - maximum number of objective function evaluations for optimisations used to 
                  determine mesh line locations.
  
  costFuncTol - stopping tolerance on cost functions used for optimisations used to 
                  determine mesh line locations. 

  isPlot - whether to plot mesh line statistics.
  
Per group option summary:

  options.group().
  
  ------------------------------------------------------------------------------------------
  Name                   Type     Default   Units Range
  ------------------------------------------------------------------------------------------
  materialName           string   'PEC'     -     -
  useDensity             boolean  true      -     true, false
  Dmin                   real     10.0      -     >0.0
  Dmax                   real     20.0      -     >0.0, >=Dmax
  dmin                   real     1e-2      m     >0.0
  dmax                   real     1e-2      m     >0.0, >=dmin
  weight                 real     1.0       -     >=-Inf, <=Inf
  ------------------------------------------------------------------------------------------  

  materialName - name of the material an object is composed of. Used for determining
                 mesh density from material database.
                 
  useDensity - if true the mesh size limits for the group will be determined from the
               specified mesh densities and the material properties of the object over
               the range specified by the global minFreq and maxFreq parameters.
              
  Dmin - minimum mesh line density. Used if useDensity is true.
              
  Dmax - maximum mesh line density. Used if useDensity is true.  
  
  dmin - minimum mesh size. Used if useDensity is false.
  
  dmax - maximum mesh size. Used if useDensity is false.
  
  weight - weighting factor used for constraint points in this group.
  
Group mapping options
---------------------

Global options summary:
 
  options.mesh.

  options.mesh.
  
  --------------------------------------------------------------------------------------------------
  Name                          Type            Default       Units Range
  --------------------------------------------------------------------------------------------------

  --------------------------------------------------------------------------------------------------
  
Per group option summary:

  options.group().
  
  ------------------------------------------------------------------------------------------
  Name                   Type     Default     Units Range
  ------------------------------------------------------------------------------------------
  type                   string   'VOLUME'    -     'VOLUME', 'SURFACE', 'CLOSED_SURFACE' , 
                                                    'WIRE', 'BBOX', 'NODE' 
  isValidNormals         boolean  false       -     true, false
  isInvertNormals        boolean  false       -     true, false
  precedence             integer  1           -     >=0
  rayDirections          string   'xyz'       -     'x', 'y', 'z', 'd', 'e', 'f'
  reduceMethod           string   'CONCENSUS' -     'CONCENSUS', 'MAJORITY', 'DICTATOR'
  splitMethod            string   'SAH'       -     'SAH', 'MEDIAN', 'EQUAL'
  maxDepth               integer  15          -     >0
  minNumElemPerNode      integer  5000        -     >0
  maxNumElemPerNode      integer  Inf         -     >0, >minNumElemPerNode
  isPlot                 boolean  false       -     true, false
  isInfiniteRay          boolean  true        -     true, false
  epsParallelRay         real     1e-12       ?     >0
  isTwoSidedTri          boolean  true        -     true, false
  isIncludeRayEnds       boolean  true        -     true, false
  epsRayEnds             real     1e-6        ?     >0.0
  epsUniqueIntersection  real     1e-6        ?     >0.0
  isUseInterpResolver    boolean  false       -     true, false
  epsResolver            real     1e-12       ?     >0
  isUnresolvedInside     boolean  true        -     true, false
  ------------------------------------------------------------------------------------------

  type - type of object used to determine appropriate mapping algorithm.
 
         'VOLUME' - group is a VOLUME object desrcibed by a closed surface in the unstructured mesh group.
                   Closedness is assumed but not check.

         'SURFACE' - group is an open or closed surface object.

         'CLOSED_SURFACE' - group is a closed surface (shell). If the surface is known to be closed
                            a more robust algorithm is applied: The group is first mapped as a volume
                            object and then the faces of the mapped volume object are identified. This
                            approach is less susceptible to meshing artefacts than the general surface
                            algorithm.

         'WIRE' - group is a line object.

         'BBOX' - group is a bounding box oject. Only the bounding box of the object is utilized. This is
                  used for defining the computational volume in the input mesh and can be used to define
                  source plane, observers volumes etc.  

         'NODE' - group is a set of nodes.

  isValidNormals - indicates the normals of the mesh elements in this group can be
                   assumed to be valid, i.e. for a closed object they are all outward
                   normals according to a clockwise node number order convention. This helps
                   in the detection of some singularities in the group mapping.
                   
  isInvertNormals - indicates the normals of the mesh elements in this group can be
                    assumed to be valid but are inverted, i.e. for a closed object they 
                    are all inward normals according to a clockwise node number order convention.
  
  precedence - objects are mapped onto the structured mesh in the order of their assigned 
               precedence, lowest first. Objects with the same precedence are mapped in the
               order they appear in the unstructured mesh. 
               
  rayDirections - direction to cast rays through a volume object. This is a string composed of 
                  the characters 'x', 'y', 'z', 'e', 'f'  and 'g'. Each character should appear 
                  at most once.
                  
                  'x', 'y' and 'z' cause rays parallel to the respective direction to be cast
                  along each cell centre from the lower group AABB face to the corresponding upper
                  group AAB face. The calculation is vectorised in the normal direction and
                  much faster than with 'd', 'e' and 'f'. However, it can be more susceptible to
                  singularity arefacts.
                  
                  'd', 'e' and 'f' cause divergent rays to be cast to every cell centre on the mesh
                  from a point outside the objects bounding box along a diagonal through the bounding
                  box corners with the different cases corresponding to different diagonals of the
                  bounding box. The calculation is not vectorised and is much slower than using
                  'x', 'y' and 'z'. However if is probably more robust.
                  
  reduceMethod - If more than one direction is specified, e.g. 'xyz' then the insideness for a cell 
                 centre is determined by a vote between the results for each direction:
                  
                   CONCENSUS - cell is inside if all directions agree.
                   MAJORITY  - cell is inside if half or more of directions agree.
                   DICTATOR  - cell is inside if any direction identifies it.
                  
  splitMethod - partitioning method to use in BVH generation. 
                'SAH'    - use surface area heuristic 
                'MEDIAN' - split according to median ???? [FIXME]
                'EQUAL'  - split elements equally

  maxDepth - maximum depth of BVH tree.
  
  minNumElemPerNode - minimum number of elements in node of BVH tree. Advisory.
  
  maxNumElemPerNode - maximum number of elements in node of BVH tree. Advisory.
  
  isPlot - whether to plot statistics.
  
  epsParallelRay - tolerance [FIXME] on determining if a ray and elemenet are parallel and
                   therefore don't intersect. must be much less than epsRayEnds

  epsRayEnds - tolerance [FIXME] for determining an intersection at ends of a finite ray.

  epsUniqueIntersection - tolerance [FIXME] for determining unique interactions of rays with elements.
                          Intersections with t parameters within this tolerance will be assumed
                          to be the equivalent.

  isUseInterpResolver - determine whether to use interpolation resolver for volume mapper.

  epsResolver - tolerance on proximity of intersection at which to invoke resolver.
  
  isUnresolvedInside - default insideness for unresolved cells in volume object if
                       resolver is not used.

  [FIXME] These probably shouldn't be exposed:
  
  isInfiniteRay - 
  
  isTwoSidedTri - 

  isIncludeRayEnds - 
  
Export options
--------------

  Vulture export options summary:
  
  options.vulture.

  -----------------------------------------------------------------------------
  Name            Type     Default           Units Range
  -----------------------------------------------------------------------------
  useMaterialNames boolean  true              -     true, false
  -----------------------------------------------------------------------------
  
  useMaterialNames - if true the material name is used to tag the groups elements
                     in the Vulture mesh, otherwise the group name is used.
    
Unstructured mesh import
========================

  meshReadAmelet()
  meshReadGmsh()
  meshReadSurf()

Unstructured mesh export
========================

  meshWriteGmsh()
  meshWriteSurf()
  meshWriteWire()

  meshWriteLines2Gmsh.m
    
Unstructured mesh conversion
============================

  meshAmelet2Gmsh()
  meshGmsh2Concept()    
  meshGmsh2Surf()
  meshGmsh2Wire()
  meshSurf2Gmsh()
  
Structured mesh export
======================

  meshWriteVulture()
 
Mesh tools
==========

  meshMergeUnstructured()
  meshSmesh2Unmesh()
  meshPerimeter2Geo()
  
Structured mesh generation
==========================

  meshGetGroupIndices()
  meshCreateLines()
  meshMapGroups()

  These are internal functions:
  
  meshCalcElemProp()
  meshBuildFBVH()
  meshIntersectFBVH()
  meshLineMapGroup()
  meshSurfaceMapGroup()
  meshSurfaceMapParallelRays() 
  meshVolumeGroup2SurfaceGroup(0
  meshVolumeMapGroup()
  meshVolumeMapDivergentRays()
  meshVolumeMapParallelRays() 
  meshResolveRayVolume()

Testing
=======

  meshTestCreateLines()
  meshTestDriver()
  meshTestTimingSummary()
  meshTestFBVH()
  meshTestMapGroups()
  meshTestResolveRayVolume()
  meshTimeIntersections()
    
Tutorial example
================

View the input geometry in Gmsh

  $ gmsh cubesForNonLinearMesh.msh
  
Read the mesh into Octave/MATLAB:

  [ mesh ] = meshReadGmshFast( 'cubesForNonLinearMesh.msh' );

Define the objects group names to be meshed:

  groupNames = mesh.groupNames;

Set the default options for each group:

  [ options ] = meshSetDefaultOptions( mesh.numGroups , 'useDensity' , false , 'dmin' , 5e-2 , 'dmax' , 10e-2 , 'isUseInterpResolver' , true );

Modify global meshing options:

  options.mesh.meshType = 'CUBIC';
  options.mesh.lineAlgorithm = 'OPTIM1';
  options.mesh.costAlgorithm = 'RMS';
  options.mesh.epsCoalesceLines = 4e-3;
  options.mesh.minFreq = 1e6;
  options.mesh.maxFreq = 3e9;
  options.mesh.isPlot = false;
  options.mesh.epsCoalesceLines = 1e-4;
  options.mesh.epsCompVol = 0;
  options.vulture.useMaterialNames = false;

Set group 1 (cube 1) as a surface PEC material, mapped using
parallel rays in the x-direction:

  options.group(1).type = 'SURFACE';
  options.group(1).materialName = 'PEC';
  options.group(1).rayDirections = 'x';

Set group 2 (cube 2) as a solid PEC material, mapped using
parallel rays in the y-direction:

  options.group(2).type = 'VOLUME';
  options.group(2).materialName = 'PEC';
  options.group(2).rayDirections = 'y';

Set group 3 (cube 3) as a solid PEC material, mapped using
parallel rays in the z-direction:

  options.group(3).type = 'VOLUME';
  options.group(3).materialName = 'PEC';
  options.group(3).rayDirections = 'z';

Set group 4 (plane) as a surface PEC material, mapped using
parallel rays in the x-direction:

  options.group(4).type = 'SURFACE';
  options.group(4).materialName = 'PEC';
  options.group(4).rayDirections = 'x';

Set group 5 as the computational volume:

  options.group(5).type = 'BBOX';
  options.group(5).materialName = 'FREE_SPACE';

Create a set of uniform cubic mesh lines:

  [ lines ] = meshCreateLines( mesh , groupNames , options );

Write the mesh lines to an unstructured Gmsh mesh file:

  meshWriteLines2Gmsh( 'lines.msh' , lines );

View mesh lines together with input geometry 

  $ gmsh cubesForNonLinearMesh.msh
 
    [File]->[Merge]->lines.msh
  
Write both mesh lines and input geometry to single Gmsh mesh:

  meshWriteLines2Gmsh( 'linesAndGroups.msh' , lines , mesh );

  $ gmsh linesAndGroups.msh

Map object groups onto the structured mesh

  [ smesh ] = meshMapGroups( mesh , groupNames , lines , options );

[ unmesh ] = meshSmesh2Unmesh( smesh );

Convert mapped structured mesh to unstructured format so it can
be viewed in Gmsh:

  meshWriteGmshFast( 'mappedGroups.msh' , unmesh );
 
  $ gmsh mappedGroups.msh
  
    [File]->[Merge]->cubesForNonLinearMesh.msh

Export structured mesh to a Vulture mesh:

  meshWriteVulture( 'vulture.mesh' , smesh , options );

Convert Vulture mesh to Gmsh representation for viewing:

  $ gvulture -m -p vulture.mesh
  $ gmsh mesh.msh
  
    [File]->[Merge]->cubesForNonLinearMesh.msh


References
==========

[AMELET1.5] Cyril Giraudon, "Amelet-HDF Documentation", Release 1.5.3, AxesSim, 
            15 November 2011. 
            URL: http://amelet-hdf.googlecode.com/files/AmeletHDF-1.5.3.pdf
            
[Berens2013] Project report.

[Berens2014]] APM article.

            
Appendix A: Unstructured mesh data structure
============================================

Modelled on AMELET HDF Version 1.5.x specification [AMELET1.5].

% mesh - structure containing an unstructured mesh modelled on the AMELET-HDF format [1]:
%
%        .dimension         - integer, dimension of mesh: 1, 2 or 3.
%        .numNodes          - integer, number of nodes.
%        .nodes()           - real(dimension,numNodes), array of node coordinates [arb].
%                             nodes(i,j) gives the i-th coordinate of the j-th node.
%        .numElements       - integer, number of elements.
%        .elementTypes()    - integer(1,numElements), array of AMELET-HDF element types,
%                             Some common types are:
%
%                             1   - bar2
%                             11  - tri3
%                             13  - quad4
%                             101 - tetra4
%                             104 - hexa8
%                             199 - point (extension, not in AMELET-HDF)
%
%        .elements()        - integer(var,numElements), sparse array of element node indices.
%                             elements(i,j) gives the i-th node index (into the nodes array) of 
%                             the j-th element.
%        .numGroups         - integer, number of groups.
%        .groupNames{}      - string{numGroups}, cell array of group names.
%        .groupTypes()      - integer(numGroups), array of AMELET-HDF group types:
%
%                             0 - node
%                             1 - edge
%                             2 - face
%                             3 - volume
%
%        .groups()          - integer(var,numGroups), sparse array of node/element indices.
%                             groups(i,j) gives the index of the i-th element (into the elements
%                             array) of the j-th group.
%        .numGroupGroups    - integer, number of groups of groups.
%        .groupGroupNames{} - string{numGroupGroups}, cell array of group group names.
%        .groupGroups()     - integer(var,numGroupGroup), sparse array of group of group indices.
%                             groupGroup(i,j) gives the i-th index (into the groups array) of the
%                             j-th group of groups. Hierarchical group of groups are NOT SUPPORTED.

            
Appendix B: Structured mesh data structure
==========================================  

% smesh - structure containing a structured mesh modelled on the AMELET-HDF format [1]:
%
%        .dimension         - integer, dimension of mesh: 1, 2 or 3.
%        .x()               - real(Nx) vector of mesh line coordinates in x-direction.
%        .y()               - real(Ny) vector of mesh line coordinates in y-direction.
%        .z()               - real(Nz) vector of mesh line coordinates in z-direction.
%        .numGroups         - integer, number of groups.
%        .groupNames{}      - string{numGroups}, cell array of group names.
%        .groupTypes()      - integer(numGroups), array of AMELET-HDF group types:
%
%                             0 - node
%                             1 - edge
%                             2 - face
%                             3 - volume
%
%        .groups{}          - cell array of bounding boxes of structured mesh elements for
%                             each group. groups{groupIdx} is a nx3 or nx6 array of structured mesh
%                             indices of the bounding box corners of the elements in the group. For
%                             node groups only one coordinate is required (BBox is degenerate).
%                              
%                             For group type 0 (node): groups{groupIdx} is numNodesInGroup x 3 array
%                                                      groups{groupIdx}(nodeIdx,coordIdx)
%                                                      coordIdx = 1: i
%                                                      coordIdx = 2: j
%                                                      coordIdx = 3: k
%
%                             For all other group types: groups{groupIdx} is numBBoxInGroup x 6 array
%                                                        groups{groupIdx}(bboxIdx,coordIdx)
%                                                        coordIdx = 1: ilo
%                                                        coordIdx = 2: jlo
%                                                        coordIdx = 3: klo
%                                                        coordIdx = 4: ihi
%                                                        coordIdx = 5: jhi
%                                                        coordIdx = 6: khi  
%                                                        Boundng box can be single element (edge,face,cell)
%                                                        or multiple elements (line,surface,volume).
%              
%        .numGroupGroups    - integer, number of groups of groups.
%        .groupGroupNames{} - string{numGroupGroups}, cell array of group group names.
%        .groupGroups()     - integer(var,numGroupGroup), sparse array of group of group indices.
%                             groupGroup(i,j) gives the i-th index (into the groups array) of the
%                             j-th group of groups. Hierarchical group of groups are NOT SUPPORTED.
